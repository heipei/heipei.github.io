<!DOCTYPE html>
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en-gb">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <title>nginx-sso - Simple offline SSO for nginx</title>
        <meta name="author" content="Johannes Gilger" />
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="stylesheet" href="/css/syntax.css" type="text/css" media="all" />
        <link rel="stylesheet" href="/css/screen.css" type="text/css" media="all" />
        <link rel="canonical" href="https://heipei.github.io/2015/09/23/nginx-sso-Simple-offline-SSO-for-nginx/" />
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
             (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
             m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
             })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-40830475-1', 'github.io');
            ga('send', 'pageview');
        </script>
    </head>
    <body>
        <div class="header">
            <div class="site">
                <div class="title"><a href="/">Johannes 'heipei' Gilger</a><div class="block1"></div><div class="block2"></div><div class="block3"></div></div>
            </div>
        </div>
        <div class="site">
            <div id="post">
	<h1>nginx-sso - Simple offline SSO for nginx</h1>
	<p class="meta">23 Sep 2015</p>
	<p><strong>tl;dr</strong>: <a href="https://github.com/heipei/nginx-sso">nginx-sso</a> is a lightweight,
offline Single-Sign-On (SSO) system which works with cookies and ECDSA. It can
easily be used in together with vanilla nginx and any backend application. The
reference implementation is written in golang and has some cool additional
features such as authorization.</p>

<p>This posts describes the technical background of the system, especially the
motivation for using such a system as opposed to other established SSO
solutions. If you want a technical description of the protocol and the
authentication flow, consult the
<a href="https://github.com/heipei/nginx-sso/blob/master/TECHNICAL.md">TECHNICAL.md</a> in
the GitHub repository.</p>

<h1 id="outline">Outline</h1>
<ul>
  <li><a href="#introduction">Introduction</a> - Different types of SSO designs</li>
  <li><a href="#features">Features and similar software</a> - What does nginx-sso do (that others don’t)</li>
  <li><a href="#cookie-sso">Cookie-based SSO solutions</a> - A look at cookie-based SSO</li>
  <li><a href="#auth_request">Authentication</a> - The nginx module that makes this work</li>
  <li><a href="#authorization">Authorization</a> - The authorization / ACL functionality of nginx-sso</li>
  <li><a href="#application">Protecting applications with nginx-sso</a> - Using this with your app and other software</li>
  <li><a href="#future">Future Work</a></li>
  <li><a href="#references">References</a> - Similar projects</li>
</ul>

<p><a name="introduction" class="anchor"></a></p>

<h1 id="introduction-simple-web-based-sso">Introduction: Simple web-based SSO</h1>

<p>When I was studying at <a href="https://www.rwth-aachen.de/">RWTH Aachen University</a>, I
had a student-job at the university NOC (<a href="https://www.itc.rwth-aachen.de/">Network Operation
Center</a>). What might sound like a boring
sys-admin thing was really much more interesting as I got to develop
applications and systems to work for the roughly 50.000 people at the
university.  At some point we were told to make all of our applications work
with the newly introduced SSO-system called
<a href="https://shibboleth.net/about/basic.html">Shibboleth</a> which we used in
conjunction with
<a href="http://www.internet2.edu/products-services/trust-identity-middleware/grouper/">Grouper</a>.
I’m not going to talk about Shibboleth today as it is a huge system with a
different focus, but one thing that struck me was how easy it was to integrate
applications with Shibboleth, once it was set up.</p>

<h2 id="remote-user-and-remote-groups"><code>Remote-User</code> and <code>Remote-Groups</code></h2>
<p>Our Shibboleth setup worked by installing an Apache-module for each service
which would perform all of the SSO magic for the backend application. All the
backend application had to do was to consume the HTTP / environment variables
<code>Remote-User</code> and <code>Remote-Groups</code> and do something with them.</p>

<p>All of the sudden, the headaches of user authentication and management were
gone. No longer did your application have to implement user and credential
storage and authentication, and for authorization if often sufficed to hardcode
a specific Grouper-group into the application. Even better, a lot of available
web applications already had some support for working with <code>Remote-User</code>.</p>

<h2 id="sso-idps-openid-and-oauth">SSO, IdPs, OpenID and OAuth</h2>
<p>My time at the NOC ended in 2010. Fast-forward to 2015 and look at the
authentication landscape for modern web applications. Unless you are running
inside some corporate context, chances are you have flirted with using existing
Identity Providers (IdPs) for your project. You can choose between Google,
Facebook, LinkedIn, GitHub and more sites, neatly covering your user-base.
Outsourcing authentication to these guys is a better idea than (mis)handling
user credentials yourself!</p>

<p>While these options are definitely the way to go for most applications, there
are scenarios where they fall short:</p>

<ul>
  <li>You might not trust these providers.</li>
  <li>Your applications might live “offline”, e.g. in a corporate network.</li>
  <li>You might want to protect static resources.</li>
  <li>You might be put off by the complexity of systems like OpenID Connect.</li>
</ul>

<p>Another reality nowadays is that your app is quite likely to run behind another
HTTP process. Many people (myself included) today use nginx for terminating
TLS, load-balancing requests, etc. That’s why I decided to come up with my own
lightweight SSO which works with nginx and arbitrary applications.</p>

<p><a name="features" class="anchor"></a></p>

<h1 id="features-and-similar-software">Features and similar software</h1>

<p>When designing nginx-sso, I came up with a list of necessary and nice-to-have features:</p>

<ul>
  <li>Work offline: Neither the user nor the service has to talk to the Internet.</li>
  <li>Work disconnected: The service does not have to talk to the Identity Provider.</li>
  <li>Secure: Compromising a service must not impact any other service.</li>
  <li>Provide authentication for backend applications.</li>
  <li>Provide authorization for accessing URIs and dumb backend applications / sites.</li>
  <li>Be simple to understand and setup.</li>
  <li>Work with nginx but not require manually patching / building nginx or maintaining out-of-tree modules.</li>
</ul>

<p>The <a href="http://www.openfusion.com.au/labs/mod_auth_tkt/">Apache <code>mod_auth_tkt</code></a>
comes pretty close in terms of functionality. The big difference is that it
works as a native module only on Apache and uses shared secrets.
<a href="http://pubcookie.org/">Pubcookie</a> is another similar project. It also uses
shared keys and is available as an Apache module. Plus its more complicated.</p>

<p>The project that is closest to nginx-sso is probably
<a href="https://neon1.net/mod_auth_pubtkt/">mod_auth_pubtkt</a>, which uses RSA/DSA. It
includes a lot of similar features, but sadly is also limited to Apache. On the
other hand, it is still actively developed, so if all you need is Apache, it
might be your best choice.</p>

<p><a name="cookie-sso" class="anchor"></a></p>

<h1 id="cookie-based-sso-solutions">Cookie-based SSO solutions</h1>

<p>When thinking about disconnected / offline SSO it is obvious that the user will
provide his own credentials to the application server which has to decide
whether it is legit. That means verifying the integrity and authenticity of the
users claim, both of which are usually accomplished by using either <em>MACs</em> or
<em>signatures</em>.</p>

<p>For me, MACs were not an option since an attacker would be able to issue his
own tickets by compromising a single application server. That leaves public-key
signatures, based on DSA or ECC. ECC signatures are the better choice since
they are more efficient and take up less space in a cookie.</p>

<p>nginx-sso uses a plain cookie with an additional ECSDA signature. The signature
is made over the payload of the cookie (username, groups) as well as the expiry
timestamp and the IP of the user.</p>

<p><a name="auth_request" class="anchor"></a></p>

<h1 id="authentication">Authentication</h1>

<p>Authentication using vanilla nginx is possible mostly thanks to an awesome
nginx-plugin called
<a href="http://nginx.org/en/docs/http/ngx_http_auth_request_module.html">auth_request</a>.
From the website:</p>

<blockquote>
  <p>The ngx_http_auth_request_module module (1.5.4+) implements client
authorization based on the result of a subrequest. If the subrequest returns
a 2xx response code, the access is allowed. If it returns 401 or 403, the
access is denied with the corresponding error code. Any other response code
returned by the subrequest is considered an error.
<br /><small><b>nginx auth_request documentation</b></small></p>
</blockquote>

<p>With this module, every access to configured resources on your nginx server
will trigger an HTTP request to an authentication backend. This request will
contain the headers of the original request which your authentication backend
uses to grant or deny access. The auth_request module is not compiled by
default or in every distribution, but it is part of the mainline nginx codebase
and major distributions have packages compiled with this module.</p>

<p>Here we can see the nginx configuration snippet which protects the resource
<code>/secret</code> with a subrequest to the internal resource <code>/auth</code> which proxies to
the <strong>ssoauth</strong> server running on localhost.</p>

<figure class="highlight"><pre><code class="language-nginx" data-lang="nginx">  <span class="k">location</span> <span class="p">=</span> <span class="s">/auth</span> <span class="p">{</span>
    <span class="kn">internal</span><span class="p">;</span>
    <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8082</span><span class="p">;</span>
    <span class="kn">proxy_pass_request_body</span>     <span class="no">off</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">Content-Length</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">X-Original-URI</span> <span class="nv">$request_uri</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$http_host</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span> <span class="nv">$remote_addr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">location</span> <span class="s">/secret</span> <span class="p">{</span>
    <span class="kn">auth_request</span> <span class="s">/auth</span><span class="p">;</span>
  <span class="p">}</span></code></pre></figure>

<p><a name="variables-backend" class="anchor"></a></p>

<h2 id="passing-variables-to-the-application">Passing variables to the application</h2>

<p>While I was able to do authentication and authorization in the auth backend, it
still did not help my backend application in identifying the user. Fortunately,
I discovered how to pass variables that are returned by the auth endpoint to the
backend applications, see the example
<a href="https://github.com/heipei/nginx-sso/blob/master/etc/nginx.conf">nginx.conf</a>.
Now the backend service can simply assume the presense and correctness of these
HTTP headers and does not have to deal with the <strong>sso</strong> cookie at all.</p>

<figure class="highlight"><pre><code class="language-nginx" data-lang="nginx"><span class="k">location</span> <span class="s">/secret</span> <span class="p">{</span>
  <span class="kn">auth_request</span> <span class="s">/auth</span><span class="p">;</span>

  <span class="kn">auth_request_set</span> <span class="nv">$user</span> <span class="nv">$upstream_http_remote_user</span><span class="p">;</span>
  <span class="kn">proxy_set_header</span> <span class="s">Remote-User</span> <span class="nv">$user</span><span class="p">;</span>
  <span class="kn">auth_request_set</span> <span class="nv">$groups</span> <span class="nv">$upstream_http_remote_groups</span><span class="p">;</span>
  <span class="kn">proxy_set_header</span> <span class="s">Remote-Groups</span> <span class="nv">$groups</span><span class="p">;</span>
  <span class="kn">auth_request_set</span> <span class="nv">$expiry</span> <span class="nv">$upstream_http_remote_expiry</span><span class="p">;</span>
  <span class="kn">proxy_set_header</span> <span class="s">Remote-Expiry</span> <span class="nv">$expiry</span><span class="p">;</span>

  <span class="kn">[...]</span>
  <span class="s">proxy_information_for_backend_application</span><span class="p">;</span>
  <span class="kn">[...]</span>
<span class="err">}</span></code></pre></figure>

<p><a name="authorization" class="anchor"></a></p>

<h1 id="authorization">Authorization</h1>

<p>As a nice side-effect, since we’re already making a subrequest for each HTTP
request, we can also use the auth endpoint to do authorization. To do that,
I’ve implemented a very rudimentary ACL in ssoauth. It has a list of vhosts and
prefixes and for each of those contains a list of allowed users and groups.
This way, even static resources can easily be protected.</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="s2">&quot;acl&quot;</span><span class="err">:</span> <span class="p">{</span>
  <span class="nt">&quot;auth.domain.dev:8080&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;Users&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;jg123456&quot;</span><span class="p">],</span>
    <span class="nt">&quot;Groups&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;x:&quot;</span><span class="p">],</span>
    <span class="nt">&quot;UrlPrefixes&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;/secret/&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;Users&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;ba514378&quot;</span><span class="p">,</span> <span class="s2">&quot;jb759123&quot;</span><span class="p">],</span>
        <span class="nt">&quot;Groups&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;y:engineering:cloud&quot;</span><span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><a name="application" class="anchor"></a></p>

<h1 id="protecting-applications-with-nginx-sso">Protecting applications with nginx-sso</h1>

<p>If you are writing a custom application and want to use this (or a similar)
system, it really could not be easier. You can simply use the <code>Remote-User</code> and
<code>Remote-Groups</code> headers to do authorization, for example by saying <em>Everyone in
group xyz is an admin</em>. Alternatively, you can have your own user-database and
only use the <code>Remote-User</code> header to create and later look up the correct user.
This way you can have additional attributes (and permissions) for each user.</p>

<p>If you are using stock software you might be able to use this scheme as well. A
lot of software comes with support for logging in via <code>Remote-User</code>, even if
the software then implements its own user-database on top of this. For
closed-source software you can sometimes find plugins which enable this
functionality.</p>

<p><a name="future" class="anchor"></a></p>

<h1 id="future-work">Future work</h1>

<p>Development of nginx-sso is at the very beginning, both in terms of code
quality and features. I have a lot of things still written down in my
<a href="https://github.com/heipei/nginx-sso/blob/master/TODO.md">TODO</a> file. I’d
appreciate any help in making the codebase more readable and examining any
potential weaknesses of the current system.</p>

<p><a name="references" class="anchor"></a></p>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://github.com/heipei/nginx-sso/">https://github.com/heipei/nginx-sso/</a> - The code on GitHub</li>
  <li><a href="https://neon1.net/mod_auth_pubtkt/">https://neon1.net/mod_auth_pubtkt/</a> - mod_auth_pubtkt, a project which almost works like nginx-sso</li>
  <li><a href="http://www.openfusion.com.au/labs/mod_auth_tkt/">http://www.openfusion.com.au/labs/mod_auth_tkt/</a> - Apache mod_auth_tkt</li>
  <li><a href="http://pubcookie.org/">Pubcookie</a> - Pubcookie system</li>
  <li><a href="https://developers.shopware.com/blog/2015/03/02/sso-with-nginx-authrequest-module/">https://developers.shopware.com/blog/2015/03/02/sso-with-nginx-authrequest-module/</a> - Describes a basic setup of using auth_request with cookies.</li>
  <li><a href="https://news.ycombinator.com/item?id=7641148">https://news.ycombinator.com/item?id=7641148</a> - Hackernews thread discussing auth_request and different approaches to SSO.</li>
  <li><a href="http://www.vanko.me/book/page/pubcookie-module-nginx">http://www.vitki.net/book/page/pubcookie-module-nginx</a> - A third-party Pubcookie implementation for nginx, out of date and not maintained.</li>
</ul>

<h1 id="social">Social</h1>

<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-via="heipei">Tweet</a>&nbsp;&nbsp;
<a href="https://twitter.com/heipei" class="twitter-follow-button" data-show-count="false">Follow @heipei</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
</p>


</div>
<!--

<div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li><span>28 May 2016</span> <span class="seperator">~</span> <a href="/2016/05/28/jekyll-and-responsive-flickr-photos/">Jekyll and responsive Flickr photos</a></li>
    
      <li><span>20 Aug 2015</span> <span class="seperator">~</span> <a href="/2015/08/20/Persistent-AppCache-Injections/">Persistent AppCache Injections</a></li>
    
      <li><span>29 Apr 2015</span> <span class="seperator">~</span> <a href="/2015/04/29/OpenSSH-Secure-Networking-Swiss-Army-Knife/">OpenSSH - Secure Networking Swiss-Army Knife</a></li>
    
  </ul>
</div>

-->
<div class="comments">
	<h3>Comments</h3>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'heipei'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    

</div>

            <div class="footer">
                <div class="contact">
                    <p>Johannes Gilger - <a href="https://twitter.com/heipei/">@heipei</a></p>
                </div>
                <div class="rss">
                    <i class="icon-rss"></i> <a href="/atom.xml">Atom Feed</a>
                </div>
            </div>
        </div>
    </body>
    <html>
